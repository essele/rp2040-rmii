.program mac_rx_100
; 
; So we have three pins: rx0 and rx1 as input, and crs as jmp
; We are running at 100Mhz, so we have two cycles per clock!
; We first need to wait for crs to be low for two mac cycles (4 clock)
.wrap_target
idlewait:
    jmp pin idlewait
    jmp pin idlewait
    jmp pin idlewait
    jmp pin idlewait

; Theoretically we now have an idle situation...
; Now we wait for crs to go high....

crswait:
    jmp pin highwait [1]
    jmp crswait [1]

; Now we can look for both pins high
highwait:
    wait 1 pin 0 [1]
    wait 1 pin 1 [1]

; At 100M we can check RXDV each time and it's fine, however at
; 10M this line is only valid on the second half of the nibble
; so we read two lots and then check...
start:
    in pins, 2 [1]
    in pins, 2
    jmp pin start
    irq wait 0 rel

; TODO: We randomly end up with spurious data in here at 100meg??
    set x, 0
    mov isr, x

;done:
;    jmp done
.wrap


.program mac_rx_10
; 
; For 10M we stick at a /1 clkdiv, so we can synchronise with the
; clock, otherwise we're at random parts of the cycle
;
; So we have three pins: rx0 and rx1 as input, and crs as jmp

; First wait for CRS to go low... this needs to be for 20 cycles (2 clocks) to
; avoid the toggling at the end of the packet.
.wrap_target
idlestart:
    set x 9
idlewait:
    jmp pin idlestart
    jmp x-- idlewait

; Now wait for crs to ho high again to signal the start of the packet
crswait:
    jmp pin highwait
    jmp crswait

; Now wait for both pins to go high, once we have that we wait a bit to put
; us inside the next data cycle by a couple of clocks
highwait:
    wait 1 pin 0
    wait 1 pin 1
    nop [25]

; We can ready the first dibit in the first 20 cycles, then the second dibit
; as well as sampling CRS to check for the end of the packet
start:
    in pins, 2 [19]         ; 20 cycles
    in pins, 2              ; 1 cycle
    jmp pin start [18]      ; 19 cycles
    irq wait 0 rel

; TODO: We end up with spurious data in here at 10meg, so I suspect the previous
; check isn't quite right?
    set x, 0
    mov isr, x

;done:
;    jmp done
.wrap


% c-sdk {
//
// Different way of doing this ... load the program into the PIO, do the configuration
// don't actually start it, keep the offset (so we can unload it again.)
//
static uint rx_offset;
pio_program_t *rx_prog;

static inline int mac_rx_load(PIO pio, uint sm, uint pin_rx0, uint pin_crs, int speed) {
    pio_sm_config c;

    if (speed == 10) {
        rx_prog = (pio_program_t *)&mac_rx_10_program;
        rx_offset = pio_add_program(pio, rx_prog);
        c = mac_rx_10_program_get_default_config(rx_offset);
    } else {
        rx_prog = (pio_program_t *)&mac_rx_100_program;
        rx_offset = pio_add_program(pio, rx_prog);
        c = mac_rx_100_program_get_default_config(rx_offset);
    }

    // Setup the configuration...
    sm_config_set_in_pins(&c, pin_rx0);
    sm_config_set_jmp_pin(&c, pin_crs);

    // Connect PIO to the pads (not technically needed for rx, but cleaner)
    pio_gpio_init(pio, pin_rx0);
    pio_gpio_init(pio, pin_rx0+1);
    pio_gpio_init(pio, pin_crs);

    // Set the pin direction to input at the PIO
    pio_sm_set_consecutive_pindirs(pio, sm, pin_rx0, 2, false);     // input
    pio_sm_set_consecutive_pindirs(pio, sm, pin_crs, 1, false);     // input

    // Set direction, autopull, and shift sizes
    sm_config_set_in_shift(&c, true, true, 8);                      // shift right, autopush, 8 bits

    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);                  // join the RX fifos

    pio_interrupt_clear(pio, sm);
    pio_set_irq0_source_enabled(pio, pis_interrupt0 + sm, true);

    // Load our configuration, and get ready to start...
    pio_sm_init(pio, sm, rx_offset, &c);
}

static inline void mac_rx_unload(PIO pio, uint sm) {
    pio_sm_set_enabled(pio, sm, false);
    pio_interrupt_clear(pio, sm);
    pio_set_irq0_source_enabled(pio, pis_interrupt0 + sm, false);
    pio_remove_program(pio, rx_prog, rx_offset);
}

%}